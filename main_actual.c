#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Sensor, in2,    Lift_Pot,       sensorPotentiometer)
#pragma config(Sensor, in3,    Intake_Pot,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  Drive_Encode,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  ChainBar_In_Switch, sensorTouch)
#pragma config(Sensor, dgtl5,  Mogo_Out_Switch, sensorTouch)
#pragma config(Sensor, dgtl6,  Mogo_In_Switch, sensorTouch)
#pragma config(Sensor, dgtl7,  Lift_Down_Switch, sensorTouch)
#pragma config(Sensor, dgtl8,  Mogo_Tip,       sensorDigitalOut)
#pragma config(Motor,  port1,           R_B_Drive,     tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           Mogo_1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           R_Chain_Bar,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           R_F_Drive,     tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           R_Lift,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           L_Lift,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           L_F_Drive,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           L_Chain_Bar,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           Intake_1,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          L_B_Drive,     tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Durati6on Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(45)
#pragma userControlDuration(75)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Dynamical properties of robot

#define Base_Robot_Mass 6.7 // In Kg
#define Mass_Conversion_Factor .00043
float Robot_Mass = Base_Robot_Mass*Mass_Conversion_Factor;
#define Base_Mobile_Goal_Mass 1.7
#define Mobile_Goal_Mass (Base_Mobile_Goal_Mass*Mass_Conversion_Factor) // Kg

#define Base_Robot_MOI .17 // Kg-M^2
#define MOI_Conversion_Factor .05
float Robot_MOI = Base_Robot_MOI*MOI_Conversion_Factor;// + .08+0.06;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// prototypes
task Tank_Drive();
  #define Drive_Threshold 8

task Joystick_Velocity_Control();
	#define Joystick_Change_Threshold 15
	int L_Joystick;
	int R_Joystick;

task Tele_Mogo();
	short Mogo_Action_Number = 0;		// 1 if last mogo action brought mogo intake in, -1 if last mogo action brought mogo out (Used to determine passive power)
	short Mogo_In = 0;		// is 1 if either of the in swithces are pressed, 0 otherwise
	short Mogo_Out = 0;		// is 1 if either of the out switches are pressed, 0 otherwise

task Tele_Lift();
	short Lift_Action_Number = 0;		// 1 if last lift action brought lift down, -1 if last lift action brought lift up (Used to determine passive power)
	short Lift_Down = 0;		// is 1 if either of the in swithces are pressed, 0 otherwise

task Tele_Chain_Bar();

task Tele_Auto_Stacker();
	short Cone_Counter = 0;
	#define Stacker_Refresh_Time 20
 	#define P_Stacker 1.0
  #define D_Stacker .1
	#define Stacker_Error_Threshold 250
	#define Stacker_Count_Limit 1

task Tele_Intake();
	short Intake_Action_Number = 0;		// 1 if last intake action brought intake in, -1 if last intake action brought intake out (Used to determine passive power)
	short Tele_Intake_Passive_Power = 30;

void Drive(int Power, int Target_Value);
	short Drive_Enable = 0;

typedef struct {
	int Power;
	int Target;
	short Target_Sign;
	int Offset;
} PIDControl;

task Auto_Drive();
	PIDControl DrivePID;
	#define Drive_Refresh_Time 20 // in miliseconds
	#define P_Drive 1.25 	// needs to be large enough to get us to the target from any displacement
	#define D_Drive (sqrt(4*P_Drive*Robot_Mass)) // This is determined by solving 2nd order diff eq for critical damping. See notebook
	#define Drive_Power_Minimum 12
	#define Drive_BreakOut_Counter_Limit (ceil(100/(float)Drive_Refresh_Time)) 		// corresponds to ~.10 seconds
	#define Drive_Breakout_D 10

task Drive_Assist();
	short Drive_Assist_Enable = 0;
	int L_Drive_Correction = 0;
	int R_Drive_Correction = 0;
	#define Drive_Assist_Refresh_Time 20 // in miliseconds
	#define P_Drive_Assist 3.5
  #define D_Drive_Assist (sqrt(4*P_Drive_Assist*Robot_MOI))

void Initialize_Gyro(void);

void Turn(int Power, int Angle);
	short Turn_Enable = 0;

task Auto_Turn();
	PIDControl TurnPID;
	#define Gyro_Scale .94
	#define Turn_Refresh_Time 20 // in miliseconds
	#define P_Turn 5.00 	// needs to be large enough to get us to the target from any displacement
	#define D_Turn (sqrt(4*P_Turn*Robot_MOI)) // This is determined by soling 2nd order diff eq for critical damping. See notebook
	#define Turn_Power_Minimum 8
	#define Turn_BreakOut_Counter_Limit (ceil(100/Turn_Refresh_Time)) 		// corresponds to ~.10 seconds
	#define Turn_BreakOut_D 10

void Mogo(int Power);
	short Mogo_Enable = 0;

task Auto_Mogo();
	short Mogo_Power = 0;
  #define Mogo_Refresh_Time 25

void Auto_Stack(int* ConeCount_Ptr, int Direction);

/*
task Auto_Lift();
	int Lift_Power = 0;
	const int Lift_Refresh_Time = 25;
*/

void Chain_Bar_Up(int Power);
	int Chain_Bar_Enable = 0;

task Auto_Chain_Bar();
	int Chain_Bar_Power = 0;
  #define Chain_Bar_Refresh_Time 25

/*
void Intake(int Power);
	int Intake_Enable = 0;

task Auto_Intake();
	int Intake_Power = 0;
	const int Intake_Refresh_Time = 25;
*/

task Tele_Mogo_Tipper();

task LCD();
	int timer;

const unsigned short Power_Array[128] = {
	0, 15, 15, 15, 15, 15, 15, 16, 16, 16,
	16, 16, 16, 16, 16, 16, 16, 16, 16, 17,
	17, 17, 17, 17, 17, 18, 18, 18, 18, 18,
	18, 19, 19, 19, 19, 20, 20, 20, 20, 20,
	21, 21, 21, 21, 22, 22, 22, 22, 23, 23,
	23, 24, 24, 24, 24, 25, 25, 26, 26, 26,
	26, 27, 27, 27, 28, 28, 28, 28, 29, 29,
	29, 30, 30, 31, 31, 31, 32, 32, 33, 33,
	34, 34, 35, 35, 35, 36, 37, 37, 38, 38,
	39, 40, 41, 42, 42, 43, 43, 44, 45, 46,
	47, 48, 49, 51, 52, 52, 54, 56, 56, 58,
	59, 61, 62, 65, 67, 70, 73, 75, 77, 79,
	84, 84, 85, 86, 86, 87, 88, 89
};

void Set_Drive(int L_Drive_Power, int R_Drive_Power);
	int L_Drive_Sign;
	int R_Drive_Sign;
	int L_Drive_Speed;
	int R_Drive_Speed;

void Lock_Drive();

void Set_Mogo(int Power);

void Set_Lift(int Power);

void Set_Chain_Bar(int Power);

void Set_Intake(int Power);


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Driver-Control tasks and functions

task Tank_Drive() {
	// Declare local variables
	int L_Drive_Power;
	int R_Drive_Power;

	while(true) {
		// Update drive powers
		L_Drive_Power = (abs(vexRT[Ch3]) > Drive_Threshold) ? L_Joystick : 0;
		R_Drive_Power = (abs(vexRT[Ch2]) > Drive_Threshold) ? R_Joystick : 0;

		// Set drive
		Set_Drive(L_Drive_Power, R_Drive_Power);

		// Delay and loop
		wait1Msec(10);
		continue;
	} // while (true)
} // task Drive_Control()


task Joystick_Velocity_Control() {
	////////////////////////////////////////////////////////////////////////
	// Set up variables
	int Current_L_Joystick;
	int Old_L_Joystick;
	int Change_In_L_Joystick;
	int Sign_Change_In_L_Joystick;

	int Current_R_Joystick;
	int Old_R_Joystick;
	int Change_In_R_Joystick;
	int Sign_Change_In_R_Joystick;


	////////////////////////////////////////////////////////////////////////
	// Assign Old/Current values
	Current_L_Joystick = vexRT[Ch3];
	Old_L_Joystick = L_Joystick;

	Current_R_Joystick = vexRT[Ch2];
	Old_R_Joystick = R_Joystick;

	while(true) {

		////////////////////////////////////////////////////////////////////////
		// Update current values;
		Current_L_Joystick = vexRT[Ch3];
		Current_R_Joystick = vexRT[Ch2];

		////////////////////////////////////////////////////////////////////////
		// Update change values
		Change_In_L_Joystick = Current_L_Joystick - Old_L_Joystick;
		Sign_Change_In_L_Joystick = (Change_In_L_Joystick > 0) - (Change_In_L_Joystick < 0);

		Change_In_R_Joystick = Current_R_Joystick - Old_R_Joystick;
		Sign_Change_In_R_Joystick = (Change_In_R_Joystick > 0) - (Change_In_R_Joystick < 0);


		////////////////////////////////////////////////////////////////////////
		// Compare to previous value, change L/R joystick values if we're changing too quickly
		if (abs(Change_In_L_Joystick) > Joystick_Change_Threshold) {
			Current_L_Joystick = Old_L_Joystick + Sign_Change_In_L_Joystick*Joystick_Change_Threshold;
		}
		else {
			Current_L_Joystick = Current_L_Joystick;
		} // if (abs(L_Joystick_Change) > Joystick_Change_Threshold)

		if (abs(Change_In_R_Joystick) > Joystick_Change_Threshold) {
			Current_R_Joystick = Old_R_Joystick + Sign_Change_In_R_Joystick*Joystick_Change_Threshold;
		}
		else {
			Current_R_Joystick = Current_R_Joystick;
		} // if (abs(R_Joystick_Change) > Joystick_Change_Threshold)


		////////////////////////////////////////////////////////////////////////
		// Set global joystick values, loop
		L_Joystick = Current_L_Joystick;
		R_Joystick = Current_R_Joystick;

		////////////////////////////////////////////////////////////////////////
		// Update Old joystick values, wait, loop
		Old_L_Joystick = Current_L_Joystick;
		Old_R_Joystick = Current_R_Joystick;

		wait1Msec(20);
		continue;
	} // while (true)
} // task Joystick_Velocity_Control()


task Tele_Mogo(){
	while(true) {
		// Update Mogo_In, Mogo_Out
		Mogo_In = SensorValue[Mogo_In_Switch];
		Mogo_Out = SensorValue[Mogo_Out_Switch];

		if(vexRT[Btn5D] == 1 && vexRT[Btn5U] == 0 && Mogo_Out == 0) {
			Set_Mogo(100);
			Mogo_Action_Number = -1;
		} // 	if(vexRT[Btn7U] == 1 && vexRT[Btn7D] == 0 && Mogo_Out == 0) {
		else if(vexRT[Btn5D] == 0 && vexRT[Btn5U] == 1 && Mogo_In == 0) {
			Set_Mogo(-100);
			Mogo_Action_Number = 1;
		} // 	else if(vexRT[Btn7U] == 0 && vexRT[Btn7D] == 1 && Mogo_In == 0) {
		else {
			if(Mogo_In == 1) {
				Set_Mogo(10);
			} // if(Mogo_In == 1) {
			else if(Mogo_Out == 1) {
				Set_Mogo(-10);
				Cone_Counter = 0;
			} // else if(Mogo_Out == 1) {
			else if(Mogo_Action_Number == 1) {
				Set_Mogo(-10);
			} // else if(Mogo_Action_Number == 1) {
			else if(Mogo_Action_Number == -1) {
				Set_Mogo(10);
			} // else if(Mogo_Action_Number == -1) {
			else {
			  Set_Mogo(0);
			} // else {
		} // 	else {
	} // while(true) {
} // task Tele_Mogo(){

task Tele_Lift(){
	while(true) {
		// Update Lift_Down
		Lift_Down = SensorValue[Lift_Down_Switch];

		if(vexRT[Btn6U] == 1 && vexRT[Btn6D] == 0) {
			Set_Lift(-100);
			Lift_Action_Number = 1;
		} // 	if(vexRT[Btn5U] == 1 && vexRT[Btn5D] == 0 && Lift_Down == 0) {
		else if(vexRT[Btn6U] == 0 && vexRT[Btn6D] == 1 && Lift_Down == 0) {
			Set_Lift(100);

			// Run intake in if lift is out/close to ground
			if(SensorValue[ChainBar_In_Switch] == 0 && SensorValue[Lift_Pot] > 1700) { Tele_Intake_Passive_Power = 90; }
			else { Tele_Intake_Passive_Power = 30; }

			Lift_Action_Number = -1;
		} // 	else if(vexRT[Btn5U] == 0 && vexRT[Btn5D] == 1) {
		else {
			// Only update if chainbar isn't running
			if(vexRT[Btn6D] == 0) { Tele_Intake_Passive_Power = 30; }

			if(Lift_Down == 1) {
				Set_Lift(15);
			} // else if(Lift_Down == 1) {
			else if(Lift_Action_Number == 1) {
				Set_Lift(-10);
			} // else if(Lift_Action_Number == 1) {
			else if(Lift_Action_Number == -1) {
				Set_Lift(10);
			} // else if(Lift_Action_Number == -1) {
			else {
			  Set_Lift(0);
			} // else {
		} // 	else {
	} // while(true) {
} // task Tele_Lift(){

task Tele_Auto_Stacker() {
	while(true) {

		int Stacker_Lift_Error;
		int Stacker_Lift_Target;
		int Stacker_Lift_Power = 0;
		float Stacker_Lift_Delta, Stacker_Lift_Delta_h, Stacker_Lift_Delta_2h;
		float Stacker_Lift_Derivative;
		char Stacker_Lift_At_Target = 1;
		int Stacker_Error_Sign;
		int Stacker_timer;

		if(vexRT[Btn8R] == 1 && SensorValue[ChainBar_In_Switch] == 0) {
				stopTask(Tele_Lift);
				stopTask(Tele_Chain_Bar);

				// This is for when we drop off mogo/want to release without grabbing the top cone
				if(SensorValue[Mogo_In_Switch] != 1) {
					Tele_Intake_Passive_Power = -100;

					// Set Lift pot to slightly higher than current value so that lift goes up when releasing
					Stacker_Lift_Target = SensorValue[Lift_Pot] - 200;
					wait1Msec(150);
				}
				else {	 // For when not dropping of mogo
					Stacker_Lift_Target = 2450 - 105*Cone_Counter;
				}

				// Set Target, (at target = 0 means we are not at the target)
				Stacker_Lift_At_Target = 0;

				// Setup timer (to prevent indefinate stall)
				clearTimer(T1);
				Stacker_timer = time1(T1);

				// Set up derivative stuff
				Stacker_Lift_Delta_h = Stacker_Lift_Delta;
				Stacker_Lift_Delta_2h = Stacker_Lift_Delta_h;
				Stacker_Lift_Derivative = 0;

				// Loop until chainbar is up, or timer is done
				while(SensorValue[ChainBar_In_Switch] == 0 && Stacker_timer < 2000) {
					// Set up error, target. Note, lower pot values indicate being up higher.
					// Thus, a neg error corresponds to being above target (when we want + power)
					// Pos error corresponds to being below target.
					Stacker_Lift_Error = SensorValue[Lift_Pot] - Stacker_Lift_Target;

					// Update Derivative
					Stacker_Lift_Delta_2h = Stacker_Lift_Delta_h;
					Stacker_Lift_Delta_h = Stacker_Lift_Delta;
					Stacker_Lift_Delta = Stacker_Lift_Error;
					Stacker_Lift_Derivative = (1000./(2.*(float)Stacker_Refresh_Time))*(float)(3.*Stacker_Lift_Delta - 4.*Stacker_Lift_Delta_h + Stacker_Lift_Delta_2h);

					// Enable ChainBar if Error is below threshold
					if(abs(Stacker_Lift_Error) <= Stacker_Error_Threshold) { Stacker_Lift_At_Target = 1; }

					// Calculate power, make sure it is less than 120
					Stacker_Lift_Power = P_Stacker*Stacker_Lift_Error + D_Stacker*Stacker_Lift_Derivative;
					Stacker_Error_Sign = (Stacker_Lift_Error > 0) - (Stacker_Lift_Error < 0);
					Stacker_Lift_Power = (abs(Stacker_Lift_Power) > 100) ? 100*Stacker_Error_Sign : Stacker_Lift_Power;

					// Deal with chain bar.
					// Increase chainbar power to prevent dropping while accelerating up
					if(Stacker_Lift_At_Target == 0) {
						// Check if chainbar is too low or too high
						if(SensorValue[Intake_Pot] > 3000) { Set_Chain_Bar(-100); }
						else if(SensorValue[Intake_Pot] < 2300) { Set_Chain_Bar(0); }
						else { Set_Chain_Bar(-25); }
					} // 	if(Stacker_Lift_At_Target == 0) {
					else if(Stacker_Lift_At_Target) {
						Set_Chain_Bar(-100);
					}

					// Set lift. Note, we send negative because neg on lift means up.
					Set_Lift(-Stacker_Lift_Power);

					wait1Msec(Stacker_Refresh_Time);
					Stacker_timer = time1(T1);
				} // while(SensorValue[ChainBar_In_Switch] == 0) {

				// Increment cone count, stop chainbar, reset Intake Passive power (we changed it if we're dropping off mogo)
				Cone_Counter++;
				Set_Chain_Bar(-10);
				Tele_Intake_Passive_Power = 30;

				// Restart tasks that we shut down, return control to them
				startTask(Tele_Chain_Bar);
				startTask(Tele_Lift);
		} // (vexRT[Btn8R] == 1 && SensorValue[Chainbar_In_Switch] == 0) {

		else if(vexRT[Btn8R] == 1 && SensorValue[ChainBar_In_Switch] == 1) {

			// Stop tasks
			stopTask(Tele_Lift);
			stopTask(Tele_Chain_Bar);
			stopTask(Tele_Intake);

			Set_Intake(-100);
			Set_Lift(-100);
			wait1Msec(200);
			if(SensorValue[Lift_Pot] > 2100) {
				wait1Msec((int)(.4*(SensorValue[Lift_Pot]-2200)));
			}

			Set_Lift(-10);
			Set_Chain_Bar(100);
			wait1Msec(150);

			Set_Chain_Bar(40);
			clearTimer(T1);
			while(SensorValue[Intake_Pot] < 2300 &&  time1(T1) < 1000) {
				wait1Msec(25);
			} // while(SensorValue[Intake_Pot] < 2300) {

			Set_Intake(Tele_Intake_Passive_Power);
			Set_Chain_Bar(-20);

			startTask(Tele_Lift);
			startTask(Tele_Chain_Bar);
			startTask(Tele_Intake);
		} // else if (vexRT[Btn8R] == 1 && SensorValue[ChainBar_In_Switch] == 1) {
		else {
			wait1Msec(50);
		} // else {
	} // 	while(true) {
} // task Tele_Auto_Stacker() {

task Tele_Chain_Bar() {
	int Chain_Bar_In;
	char Chain_Bar_Pot_Limit;
	while(true) {
		// Update sensor values
	  Chain_Bar_In = SensorValue[ChainBar_In_Switch];
	  Chain_Bar_Pot_Limit = (SensorValue[Intake_Pot] < 3800);

		if(vexRT[Btn8U] == 1 && Chain_Bar_In == 0) {
			Chain_Bar_Power = -100;
			Tele_Intake_Passive_Power = 30;
			Set_Chain_Bar(Chain_Bar_Power);
		}
		else if(vexRT[Btn8D] == 1 && Chain_Bar_Pot_Limit){
			Chain_Bar_Power = 60;
			Tele_Intake_Passive_Power = 90;		//  when the chainbar is pressed down (usually when picking up cones) run intake full power in
			Set_Chain_Bar(Chain_Bar_Power);
		}
		else {
			// For when stack is built and you're releasing mogo
			if(Cone_Counter >= 3 && vexRT[Btn5D] == 1) {
				Chain_Bar_Power = 20;
				Set_Chain_Bar(Chain_Bar_Power);
			}

			// For the rest of the time
			else {
				Chain_Bar_Power = -15;
				if(vexRT[Btn6D] == 0) { Tele_Intake_Passive_Power = 30;	}	// 30 is default value for intake passive power
				Set_Chain_Bar(Chain_Bar_Power);
			}
		}
	} // while(true) {
}	// task Tele_Chain_Bar() {

task Tele_Intake(){
	while(true) {
		if(vexRT[Btn7U] == 1) {
			Set_Intake(100);
		}
		else if(vexRT[Btn7D] == 1){
			Set_Intake(-100);
		}
		else {
			Set_Intake(Tele_Intake_Passive_Power);
		}
	} // while(true) {
} // task Tele_Intake(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Autonomous straight driving


void Drive(int Power, int Target_Value) {
	// Check that power is a positive number
	if (Power < 0) { return; }

	// Set drive global variables
	DrivePID.Power = Power;
	DrivePID.Target = Target_Value;
	DrivePID.Target_Sign = (DrivePID.Target > 0) - (DrivePID.Target < 0);

	// Enable auto_Drive
	Drive_Enable = 1;

} // void Run_Drive(int Power, int Target_Value)

task Auto_Drive() {
	// Declare Local variables
	int Drive_Pos;
	int Drive_Delta, Drive_Delta_h, Drive_Delta_2h;
	int Drive_Delta_Sign;
	float Drive_Delta_Derivative;
	int L_Drive_Power, R_Drive_Power;
	int Drive_BreakOut_Counter = 0;

	// Loop continuously, waiting to be enabled
	while(true) {
		// If enabled, set up drive stuff
		if(Drive_Enable) {
			//// Drive setup (setup once enabled, but prior to robot moving) ////

			// Reset encoders
			SensorValue[Drive_Encode] = 0;

			// Turn on drive assist
			Drive_Assist_Enable = 1;

			// Reset breakout counter
			Drive_BreakOut_Counter = 0;

			// Reset drive error
			Drive_Delta = DrivePID.Target; // This is Drive_Delta before drive has moved. This way, initial rate of change is 0.
			Drive_Delta_h = Drive_Delta;
			Drive_Delta_2h = Drive_Delta_h;
			Drive_Delta_Derivative = 0;

			// Loop while drive is enabled, breakout counter is below limit.
			while((Drive_Enable) && (Drive_BreakOut_Counter < Drive_BreakOut_Counter_Limit)) {
				// Update L,R,Avg values
				Drive_Pos = SensorValue[Drive_Encode] - DrivePID.Offset;

				// Update Drive_Deltas
				Drive_Delta_2h = Drive_Delta_h;
				Drive_Delta_h = Drive_Delta;
				Drive_Delta = (DrivePID.Target - Drive_Pos); 				// Update Error. Normalize this number such that it's 100 when we're one reference error away from target.
				Drive_Delta_Sign = (Drive_Delta > 0) - (Drive_Delta < 0); 		// update sign of error

				// PD loop //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				// Proportional //---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//

				// Derivative //---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//
				// Here we use a 3 point endpoint approximation of the derivative. f'(x) ~= (1/2h)*(3f(x) - 4f(x-h) + f(x+2h))
				Drive_Delta_Derivative = (1000./(2.*(float)Drive_Refresh_Time))*(float)(3.*Drive_Delta - 4.*Drive_Delta_h + Drive_Delta_2h);

				// Check for drive stall, add to counter if we are. This only applies if we're close to the target
				if (abs(Drive_Delta) < abs(DrivePID.Target*.7) && abs(Drive_Delta_Derivative*D_Drive) < Drive_Breakout_D) {
					Drive_BreakOut_Counter += 1;
				}
				else { Drive_BreakOut_Counter = 0; }			// Otherwise, reset breakout counter

				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

				// Assign L, R Drive_Power
				L_Drive_Power = P_Drive*Drive_Delta + D_Drive*Drive_Delta_Derivative; // Assign L

				if (abs(L_Drive_Power) > abs(DrivePID.Power)) { L_Drive_Power = (Drive_Delta_Sign)*(DrivePID.Power); }	// Limit max velocity (without correction) to drive power

				R_Drive_Power = L_Drive_Power;				// Assign R

				// Print P,D correction terms to debug stream (if connected)... mostly for tuning
				writeDebugStreamLine("P: %i D: %i",P_Drive*Drive_Delta,D_Drive*Drive_Delta_Derivative);

				/* Now, add in corrections (they diminish as you approach the target)
				if (abs(Drive_Delta) < .5*Drive_PID_Threshold) {
					L_Drive_Power += L_Drive_Correction*(2*(float)abs(Drive_Delta)/(float)Drive_PID_Threshold);
					R_Drive_Power += R_Drive_Correction*(2*(float)abs(Drive_Delta)/(float)Drive_PID_Threshold);
				} // if (abs(Drive_Delta) < Drive_PID_Threshold) {

				else {	// Case for when we're far from target, use full correcton
					L_Drive_Power += L_Drive_Correction;
					R_Drive_Power += R_Drive_Correction;
				} // else {
				*/

				L_Drive_Power += L_Drive_Correction*((float)L_Drive_Power/(float)DrivePID.Power);
				R_Drive_Power += R_Drive_Correction*((float)R_Drive_Power/(float)DrivePID.Power);

				// Now, set drive
				if(abs((L_Drive_Power + R_Drive_Power)/2.) < Drive_Power_Minimum) {
					Lock_Drive();
				}
				else {
					Set_Drive(L_Drive_Power, R_Drive_Power);
				}

				wait1Msec(Drive_Refresh_Time);
			} // while (Drive_Enable)
			//// shut down, reset global target values ////
			Set_Drive(0,0);
			DrivePID.Offset = Drive_Delta;
			DrivePID.Power = 0;
			DrivePID.Target = 0;
			DrivePID.Target_Sign = 0;
			Drive_BreakOut_Counter = 0;
			Set_Drive(0,0);
			Drive_Assist_Enable = 0;
			Drive_Enable = 0;
		}	// if(Drive_Enable)
		else {
			wait1Msec(Drive_Refresh_Time);
		} // else {
	} // while (true)
} // task Auto_Drive()


// This task makes sure the drive goes straight
task Drive_Assist(){
	// Declare Local variables
	float Angle;
	float Angle_Delta, Angle_Delta_h, Angle_Delta_2h;
	float Angle_Delta_Derivative;

	// Loop continuously, waiting to be enabled
	while(true) {
		// If enabled, set up drive stuff
		if(Drive_Assist_Enable) {
			//// Drive setup (setup once enabled, but prior to robot moving) ////
			SensorValue[Gyro] = 0;

			// Set initial offsets
			//L_Drive_Delta = -1*Drive_Assist_Offset; 				// Uses angle error from last turn
			//R_Drive_Delta = Drive_Assist_Offset;

			// Set up Drive_Deltas/derivatives
			Angle_Delta_h = Angle_Delta;
			Angle_Delta_2h = Angle_Delta_h;
			Angle_Delta_Derivative = 0;

			// Loop while drive_assist is enabled, breakout counter is below limit.
			while(Drive_Assist_Enable) {
				// Update Drive position
				Angle = .1*Gyro_Scale*((float)SensorValue[Gyro]) + TurnPID.Offset;

				// Update Drive_Deltas
				Angle_Delta_2h = Angle_Delta_h;
				Angle_Delta_h = Angle_Delta;
				Angle_Delta = Angle;					// Since an angle of 0 is the goal

				// PD loop //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				// Proportional //---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//

				// Derivative //---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//
				// Here we use a 3 point endpoint approximation of the derivative. f'(x) ~= (1/2h)*(3f(x) - 4f(x-h) + f(x+2h))
				Angle_Delta_Derivative = (1000./(2.*(float)Drive_Assist_Refresh_Time))*(float)(3.*Angle_Delta - 4.*Angle_Delta_h + Angle_Delta_2h);

				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

				// Assign L, R correction
				L_Drive_Correction = P_Drive_Assist*Angle_Delta + D_Drive_Assist*Angle_Delta_Derivative; // Assign L Correction
				L_Drive_Correction = DrivePID.Target_Sign*L_Drive_Correction; // So that the error is correct if the robot drives backwards
				R_Drive_Correction = -L_Drive_Correction; // Assign R Correction

				wait1Msec(Drive_Assist_Refresh_Time);
			} // while (Drive_Assist_Enable)
			//// shut down, reset global target values ////
			TurnPID.Offset = Angle;
			L_Drive_Correction = 0;
			R_Drive_Correction = 0;
		}	// if(Drive_Enable)
		else {
			wait1Msec(Drive_Assist_Refresh_Time);
		} // else {
	} // while (true)
} // task Drive_Assist()


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Autonomous turning drive

// This function is used to start up the Gyro
void Initialize_Gyro(void) {
	SensorType[in1] = sensorNone; //in1 is Gyro1
	wait1Msec(1000);
	SensorType[in1] = sensorGyro;
	wait1Msec(2000);
}

void Turn(int Power, int Angle) {
	// Check that power is a positive number
	if (Power < 0) { return; }

	// Set drive global variables
	TurnPID.Power = Power;
	TurnPID.Target = Angle;

	// Enable auto_Drive
	Turn_Enable = 1;

} // void Turn(int Power, int Target_Value)


task Auto_Turn() {
	// Declare Local variables
	float Angle;
	float Angle_Delta, Angle_Delta_h, Angle_Delta_2h;
	float Angle_Delta_Derivative, Angle_Delta_Sign;
	int L_Drive_Power, R_Drive_Power;
	int Turn_BreakOut_Counter;

	// Loop continuously, waiting to be enabled
	while(true) {
		// If enabled, set up drive stuff
		if(Turn_Enable) {
			//// Turn setup (setup once enabled, but prior to robot moving) ////

			// Reset Gyro
			SensorValue[Gyro] = 0;			// Use last offset as starting angle
			DrivePID.Offset = 0; 					// Reset drive offset. We're changing directions, so the drive offset no longer applies/will not move us in the right direction.

			// Reset breakout counter
			Turn_BreakOut_Counter = 0;

			// Reset turn delta
			Angle_Delta = TurnPID.Target; // This is Drive_Delta before drive has moved. This way, initial rate of change is 0.
			Angle_Delta_h = Angle_Delta;
			Angle_Delta_2h = Angle_Delta_h;
			Angle_Delta_Derivative = 0;

			// Loop while turn is enabled, breakout counter is below limit.
			while((Turn_Enable) && (Turn_BreakOut_Counter < Turn_BreakOut_Counter_Limit)) {
				// Update Angle value
				Angle = .1*Gyro_Scale*((float)SensorValue[Gyro]) + TurnPID.Offset;     // Gyro outputs angles in 10ths of a degree... divide by 10 to convert to units of degrees

				// Update Turn_Deltas
				Angle_Delta_2h = Angle_Delta_h;
				Angle_Delta_h = Angle_Delta;
				Angle_Delta = (TurnPID.Target - Angle);
				Angle_Delta_Sign = (Angle_Delta > 0) - (Angle_Delta < 0); 		// update sign of error

				// PD loop //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
				// Proportional //---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//

				// Derivative //---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//---//
				// Here we use a 3 point endpoint approximation of the derivative. f'(x) ~= (1/2h)*(3f(x) - 4f(x-h) + f(x+2h))
				Angle_Delta_Derivative = (1000./(2.*(float)Turn_Refresh_Time))*(float)(3.*Angle_Delta - 4.*Angle_Delta_h + Angle_Delta_2h);

				// Check for turn stall, add to counter if we are. This only applies if we're close to the target
				if (abs(Angle_Delta) < abs(TurnPID.Target*.5) && abs(Angle_Delta_Derivative) < D_Turn*Turn_BreakOut_D) {
					Turn_BreakOut_Counter += 1;
				}
				else { Turn_BreakOut_Counter = 0; }			// Otherwise, reset breakout counter

				/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

				// Assign L, R Drive_Power
				R_Drive_Power = P_Turn*Angle_Delta + D_Turn*Angle_Delta_Derivative; // Assign R (For CCW rotation, Right side should go forward, L backwards)

				R_Drive_Power = (abs(R_Drive_Power) < Turn_Power_Minimum) ? 0 : R_Drive_Power;	// Set L to 0 if we're very close to 0 power (prevent oscillations

				if (abs(R_Drive_Power) > abs(TurnPID.Power)) { R_Drive_Power = (Angle_Delta_Sign)*(TurnPID.Power); }	// Limit max velocity (without correction) to drive power

				L_Drive_Power = -R_Drive_Power;				// Assign L

				writeDebugStreamLine("P: %i D: %i",P_Turn*Angle_Delta,D_Turn*Angle_Delta_Derivative);

				// Now, set drive
				Set_Drive(L_Drive_Power, R_Drive_Power);

				wait1Msec(Turn_Refresh_Time);
			} // while (Turn_Enable)
			//// shut down, reset global target values ////
			TurnPID.Offset = -Angle_Delta;
			TurnPID.Power = 0;
			TurnPID.Target = 0;
			Turn_BreakOut_Counter = 0;
			Set_Drive(0,0);
			Turn_Enable = 0;
		}	// if(Turn_Enable)
		else {
			wait1Msec(20);
		} // else {
	} // while (true)
} // task Auto_Turn()

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Autonomous Mobile goal control

void Mogo(int Power) {
	// Set drive global variables
	Mogo_Power = Power;		// Mogo runs backwards

	// Enable auto_Drive
	Mogo_Enable = 1;
} // task Mogo(int Power, int Time) {

task Auto_Mogo(){
	// Set up local variables
	short Mogo_Power_Sign;
	short Mogo_In = 0;		// is 1 if either of the in swithces are pressed, 0 otherwise
	short Mogo_Out = 0;		// is 1 if either of the out switches are pressed, 0 otherwise

	while(true) {
		// Update Mogo_In and Mogo_Out (needed for passive power)
		Mogo_In = SensorValue[Mogo_In_Switch];
		Mogo_Out = SensorValue[Mogo_Out_Switch];

		if(Mogo_Enable == 1) {
			//// Mogo setup (setup once enabled, but prior to robot moving) ////

			// Determine sign of power
			Mogo_Power_Sign = (Mogo_Power > 0) - (Mogo_Power < 0);

			// Set mogo to Power (get mogo moving)
			Set_Mogo(Mogo_Power);
			Intake_Action_Number = Mogo_Power_Sign;

			// Loop while mogo is enabled
			while(Mogo_Enable == 1) {
				// Update Mogo_In, Mogo_Out
				Mogo_In = SensorValue[Mogo_In_Switch];
				Mogo_Out = SensorValue[Mogo_Out_Switch];

				if(Mogo_Power_Sign == -1 && Mogo_In == 1) {
					Set_Mogo(10);
					Mogo_Enable = 0;
					break;
				} // if(Mogo_Power_Sign == -1 && Mogo_In == 1) {
				else if(Mogo_Power_Sign == 1 && Mogo_Out == 1) {
					Set_Mogo(-10);
					Mogo_Enable = 0;
					break;
				} // else if(Mogo_Power_Sign == 1 && Mogo_Out == 1) {
				else { continue; }

				wait1Msec(Mogo_Refresh_Time);
			} // while (Mogo_Enable)

			//// shut down, reset global target values ////
			Mogo_Power = 0;
			Mogo_Enable = 0;
		}	// if(Mogo_Enable)
		else {
			if(Mogo_Out == 1) {
				Set_Mogo(10);
			} // if(Mogo_Out == 1) {
			else if(Mogo_In == 1) {
				Set_Mogo(-10);
			} // else if(Mogo_In == 1) {
			else {
				Set_Mogo(0);
			} // else {
			wait1Msec(Mogo_Refresh_Time);
		} // else {
	} // while (true)
} // task Auto_Mogo(){

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Autonomous Lift control


void Auto_Stack(int* ConeCount_Ptr, int Direction) {
	int Stacker_Lift_Error;
	int Stacker_Lift_Target;
	int Stacker_Lift_Power = 0;
	float Stacker_Lift_Delta, Stacker_Lift_Delta_h, Stacker_Lift_Delta_2h;
	float Stacker_Lift_Derivative;
	char Stacker_Lift_At_Target = 1;
	int Stacker_Error_Sign;
	int Stacker_timer;

	if(Direction == 1) {
			stopTask(Auto_Chain_Bar);

			// Set intake
			Set_Intake(20);

			// This is for when we drop off mogo/want to release without grabbing the top cone
			if(SensorValue[Mogo_In_Switch] != 1) {
				Tele_Intake_Passive_Power = -100;

				// Set Lift pot to slightly higher than current value so that lift goes up when releasing
				Stacker_Lift_Target = SensorValue[Lift_Pot] - 200;
				wait1Msec(150);
			}
			else {	 // For when not dropping of mogo
				Stacker_Lift_Target = 2450 - 110*(*ConeCount_Ptr);
			}

			// Set Target, (at target = 0 means we are not at the target)
			Stacker_Lift_At_Target = 0;

			// Setup timer (to prevent indefinate stall)
			clearTimer(T1);
			Stacker_timer = time1(T1);

			// Set up derivative stuff
			Stacker_Lift_Delta_h = Stacker_Lift_Delta;
			Stacker_Lift_Delta_2h = Stacker_Lift_Delta_h;
			Stacker_Lift_Derivative = 0;

			// Loop until chainbar is up, or timer is done
			while(SensorValue[ChainBar_In_Switch] == 0 && Stacker_timer < 1500) {
				// Set up error, target. Note, lower pot values indicate being up higher.
				// Thus, a neg error corresponds to being above target (when we want + power)
				// Pos error corresponds to being below target.
				Stacker_Lift_Error = SensorValue[Lift_Pot] - Stacker_Lift_Target;

				// Update Derivative
				Stacker_Lift_Delta_2h = Stacker_Lift_Delta_h;
				Stacker_Lift_Delta_h = Stacker_Lift_Delta;
				Stacker_Lift_Delta = Stacker_Lift_Error;
				Stacker_Lift_Derivative = (1000./(2.*(float)Stacker_Refresh_Time))*(float)(3.*Stacker_Lift_Delta - 4.*Stacker_Lift_Delta_h + Stacker_Lift_Delta_2h);

				// Enable ChainBar if Error is below threshold
				if(abs(Stacker_Lift_Error) <= Stacker_Error_Threshold) { Stacker_Lift_At_Target = 1; }

				// Calculate power, make sure it is less than 120
				Stacker_Lift_Power = P_Stacker*Stacker_Lift_Error + D_Stacker*Stacker_Lift_Derivative;
				Stacker_Error_Sign = (Stacker_Lift_Error > 0) - (Stacker_Lift_Error < 0);
				Stacker_Lift_Power = (abs(Stacker_Lift_Power) > 100) ? 100*Stacker_Error_Sign : Stacker_Lift_Power;

				// Deal with chain bar.
				// Increase chainbar power to prevent dropping while accelerating up
				if(Stacker_Lift_At_Target == 0) {
					// Check if chainbar is too low or too high
					if(SensorValue[Intake_Pot] > 2950) { Set_Chain_Bar(-100); }
					else if(SensorValue[Intake_Pot] < 2300) { Set_Chain_Bar(0); }
					else { Set_Chain_Bar(-25); }
				} // 	if(Stacker_Lift_At_Target == 0) {
				else if(Stacker_Lift_At_Target) {
					Set_Chain_Bar(-100);
				}

				// Set lift. Note, we send negative because neg on lift means up.
				Set_Lift(-Stacker_Lift_Power);

				wait1Msec(Stacker_Refresh_Time);
				Stacker_timer = time1(T1);
			} // while(SensorValue[ChainBar_In_Switch] == 0) {

			// Increment cone count, stop chainbar, reset Intake Passive power (we changed it if we're dropping off mogo)
			(*ConeCount_Ptr)++;
			Set_Chain_Bar(-10);
			Set_Lift(-10);
			Tele_Intake_Passive_Power = 30;

			// Restart tasks that we shut down, return control to them
			startTask(Auto_Chain_Bar);
	} // (vexRT[Btn8R] == 1) {

	else if(Direction == -1) {

		// Stop tasks
		stopTask(Auto_Chain_Bar);

		// Run chainbar out initially
		Set_Lift(-10);
		Set_Chain_Bar(100);
		wait1Msec(150);

		// Loop until chainbar is in ground position
		Set_Chain_Bar(40);
		Set_Intake(100);
		clearTimer(T1);
		while(SensorValue[Intake_Pot] < 2950 &&  time1(T1) < 1000) {
			if(SensorValue[Intake_Pot] > 2200) { Set_Intake(100); Set_Lift(20); }
			wait1Msec(25);
		} // while(SensorValue[Intake_Pot] < 2700) {

		// Set chainbar to passive state
		Set_Chain_Bar(-10);

		// Run lift until we're on the ground
		clearTimer(T1);
		Set_Lift(100); 	// Note, positive on lift means up
		while(SensorValue[Lift_Down_Switch] != 1 && time1(T1) < 1000) {
			wait1Msec(30);
		}

		// Set intake to passive (after waiting for a bit)
		wait1Msec(100);
		Set_Intake(20);

		startTask(Auto_Chain_Bar);
	} // else if (Direction == -1) {
} // void Auto_Stack(int ConeCount, int Direction) {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Autonomous ChainBar control
/*
void Chain_Bar_Up(int Power) {
	// Set intake global variables
	Chain_Bar_Power = -abs(Power);			// this is because chainbar runs backwards (negative power moves up)

	// Enable auto_Intake
	Chain_Bar_Enable = 1;
} // task ChainBar(int Power) {
*/

task Auto_Chain_Bar() {
	// Set up local variables
	int Chain_Bar_In = 0;		// is 1 if chainbar limit switch is 1, 0 otherwise

	while(true) {
		// Update sensor values
		Chain_Bar_In = SensorValue[ChainBar_In_Switch];

		if(Chain_Bar_Enable == 1) {
			Set_Chain_Bar(Chain_Bar_Power);

			// Loop while mogo is enabled
			while(Chain_Bar_Enable == 1) {
				// Update Mogo_In, Mogo_Out
				Chain_Bar_In = SensorValue[ChainBar_In_Switch];

				if(Chain_Bar_In == 1) {
					Set_Chain_Bar(-20);
					Chain_Bar_Enable = 0;
					break;
				} // if(Mogo_Power_Sign == 1 && Mogo_In == 1) {

				wait1Msec(Chain_Bar_Refresh_Time);
			} // while (Mogo_Enable)

			//// shut down, reset global target values ////
			Chain_Bar_Power = 0;
			Chain_Bar_Enable = 0;
		}	// if(Mogo_Enable)
		else {
			Set_Chain_Bar(-20); 		// default state
			wait1Msec(Mogo_Refresh_Time);
		} // else {
	} // while (true)
} // task Tele_Mogo(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set-Drive


void Set_Drive(int L_Drive_Power, int R_Drive_Power) {
	// Find sign of inputs
	L_Drive_Sign = (L_Drive_Power > 0) - (L_Drive_Power < 0);
	R_Drive_Sign = (R_Drive_Power > 0) - (R_Drive_Power < 0);

	// Find magnitudes
	L_Drive_Speed = abs(L_Drive_Power);
	R_Drive_Speed = abs(R_Drive_Power);

	// Make sure magnitudes are less than 127
	L_Drive_Speed = (L_Drive_Speed > 127) ? 127 : L_Drive_Speed;
	R_Drive_Speed = (R_Drive_Speed > 127) ? 127 : R_Drive_Speed;

	motor[R_B_Drive] = R_Drive_Sign*Power_Array[R_Drive_Speed];
	//motor[R_M_Drive] = R_Drive_Sign*Power_Array[R_Drive_Speed];
	motor[R_F_Drive] = R_Drive_Sign*Power_Array[R_Drive_Speed];
	motor[L_B_Drive] = L_Drive_Sign*Power_Array[L_Drive_Speed];
	//motor[L_M_Drive] = L_Drive_Sign*Power_Array[L_Drive_Speed];
	motor[L_F_Drive] = L_Drive_Sign*Power_Array[L_Drive_Speed];
} // void Set_Drive(int Power)

void Lock_Drive() {
	motor[R_B_Drive] = 7;
	//motor[R_M_Drive] = -7;
	motor[R_F_Drive] = 7;
	motor[L_B_Drive] = 7;
	//motor[L_M_Drive] = -7;
	motor[L_F_Drive] = 7;
} // void Set_Drive(int Power)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set_Mogo

void Set_Mogo(int Power) {
	motor[Mogo_1] = Power;
	//motor[Mogo_2] = Power;
} // void Set_Mogo(int Power) {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set_Lift

void Set_Lift(int Power) {
	motor[R_Lift] = Power;
	motor[L_Lift] = Power;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set_Chain_Bar

void Set_Chain_Bar(int Power) {
	motor[L_Chain_Bar] = Power;
	motor[R_Chain_Bar] = Power;
} // void Set_Chain_Bar(int Power) {


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set_Intake

void Set_Intake(int Power) {
	motor[Intake_1] = Power;
} // void Set_Intake(int Power) {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Mogo Tipper!

task Tele_Mogo_Tipper() {
	unsigned short Tipper_Button_Count =0;

	while(true) {
		if(vexRT[Btn8L] == 1 && (Tipper_Button_Count ==0)) {
			SensorValue[Mogo_Tip] = 1;
			Tipper_Button_Count=1;
			wait1Msec(400);
		} // 	if(vexRT[Btn8L] == 1 && (Tipper_Button_Count%2 ==0)) {
		else if(vexRT[Btn8L] == 1 && (Tipper_Button_Count ==1)){
			SensorValue[Mogo_Tip] = 0;
			Tipper_Button_Count=0;
			wait1Msec(400);
		} // else if(vexRT[Btn8L] == 1 && (Tipper_Button_Count%2 ==1)){
	}// while(true) {
} // task Tele_Mogo_Tipper() {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// LCD

task LCD() {
	bLCDBacklight = true;
	// Define variables
	string Bat_Main;
	string Bat_Backup;
	string Gyroscope;
	string Encode;
	string Pot;
	string L_Cor, R_Cor;
	string Offset;
	string Time;
	string Cone;

	int Enc;
	int Potent;
	float Gyro_Val;

	// Encoder + battery loop.
	while (true) {
		// Update variables
		Potent = SensorValue[Lift_Pot];
		Enc = SensorValue[Drive_Encode];
		Gyro_Val = .1*Gyro_Scale*((float)SensorValue[Gyro]);


		// Update strings
		sprintf(Bat_Main,"%1.2f",nImmediateBatteryLevel/1000.0,"V");
		//sprintf(Bat_Backup,"%1.2f",BackupBatteryLevel/1000.0,"V");
		sprintf(Encode,"%4d",Enc);
		sprintf(Gyroscope,"%5.2f",Gyro_Val);
		sprintf(Cone,"%i",Cone_Counter);
		sprintf(Pot,"%4d",Potent);
		sprintf(Time,"%i",timer);
		//sprintf(Time,"%4d",timer);
		//sprintf(L_Cor,"%4.0f",L_Drive_Correction);
		//sprintf(R_Cor,"%4.0f",R_Drive_Correction);
		//sprintf(Offset,"%4.0f",Drive_Offset);

		// 1st line
		displayLCDString(0,0,"E:");
		displayNextLCDString(Encode);
		displayNextLCDString(" P:");
		displayNextLCDString(Pot);

		// 2nd line
		displayLCDString(1,0,"M: ");
		displayNextLCDString(Bat_Main);
		displayNextLCDString(" C: ");
		displayNextLCDString(Cone);

		wait1Msec(50);
	} // while (true)
} // task LCD()

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Pre-Auto, Auto, usercontrol
void pre_auton() {
	bStopTasksBetweenModes = true;
	Initialize_Gyro();
	SensorValue[Drive_Encode] = 0;
	SensorValue[Gyro] = 0;
}

task autonomous() {
	startTask(Auto_Drive);
	startTask(Drive_Assist);
	startTask(Auto_Turn);
	startTask(Auto_Mogo);
	//startTask(Auto_Lift);
	//startTask(Auto_Intake);
	startTask(Auto_Chain_Bar);
	startTask(LCD);

	/*
	// Drive test
	clearTimer(T1);
	Drive(110,500);
	while(Drive_Enable) {
		wait1Msec(20);
	} // while(Drive_Enable) {
	timer = time1(T1);
	*/

	/*
	// Turn test
	clearTimer(T1);
	Turn(110,90);
	while (Turn_Enable) {
		wait1Msec(25);
	} // while (Turn_Enable)
	timer = time1(T1);
	*/

	/*
	// Chain Bar test
	Chain_Bar_Up(100);
	while(Chain_Bar_Enable) {
		wait1Msec(25);
	} // while(Chain_Bar_Enable) {
	*/

	/*
	// Mogo Test
	Mogo(50);
	while(Mogo_Enable) {
		wait1Msec(50);
	} // while (Turn_Enable)

	wait1Msec(2000);

	Mogo(-50);
	while(Mogo_Enable) {
		wait1Msec(50);
	} // while (Turn_Enable)
	*/

	/*
	// Turn Drive (Error hand off) test
	Turn(100,-90);
	while(Turn_Enable) {
		wait1Msec(25);
	}

	wait1Msec(2500);

	Drive(100,1500);
	while(Drive_Enable) {
		wait1Msec(25);
	}
	*/

	// Autonomous
	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Pick up first mogo, score preload on it
	int ConeCount = 0; 			// For keeping track of cones
	TurnPID.Offset = 0;
	Set_Intake(25);	// so that preload stays in
	Set_Lift(-10);	// So that lift is a little elevated

	Mogo(100);			/// Positive means out, negative means in
	Drive(120,1700);
	while(Mogo_Enable || Drive_Enable) {
		wait1Msec(25);
	} // while(Mogo_Enable || Drive_Enable) {

	Robot_MOI += (Mobile_Goal_Mass*.15*.15); 	// to account for the fact that we're carrying mobile goals
	//0.15 m is the approximate/effective radius of the mobile goals for calculating moment of inertia
	Robot_Mass += Mobile_Goal_Mass;

	// bring in mogo intake
	Mogo(-100);
	while(Mogo_Enable) {
		wait1Msec(25);
	} // while(Mogo_Enable) {

	// Drop preload
	Set_Intake(-100);
	ConeCount++;		// We have scored one cone
	wait1Msec(200);
	Set_Intake(0);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Get another two cones

	///////////////////////////////////////////
	// Get 2nd cone
	Drive(120,350);
	while(Drive_Enable) {
		wait1Msec(25);
	}

	// Pick up 2nd cone
	Auto_Stack(&ConeCount, -1);
	wait1Msec(300);

	// Score 2nd cone
	Auto_Stack(&ConeCount, 1);
	wait1Msec(400);

	// Drop off 2nd cone
	Set_Intake(-100);
	wait1Msec(200);
	Set_Intake(0);

	///////////////////////////////////////////
	// Get 3rd cone
	Drive(120,350);
	while(Drive_Enable) {
		wait1Msec(25);
	}

	// Pick up 3rd cone
	Auto_Stack(&ConeCount, -1);
	wait1Msec(300);

	// Score 3rd cone
	Auto_Stack(&ConeCount, 1);
	wait1Msec(400);

	// Drop off 3rd cone
	Set_Intake(-100);
	wait1Msec(200);
	Set_Intake(0);

	////////////////////////////////////////////////
	// Get 4th cone

	// Run chainbar out/get in position
	Auto_Stack(&ConeCount, -1);

	// Drive to get 4th cone
	Set_Intake(100);			// To suck up cone
	Drive(120,350);
	Set_Lift(20);
	while(Drive_Enable) {
		wait1Msec(25);
	}

	// Wait for some time, picks up 4th cone
	stopTask(Auto_Chain_Bar);
	Set_Chain_Bar(20);
	wait1Msec(500);
	startTask(Auto_Chain_Bar);

	// Back up a little
	Drive(120,-250);
	while(Drive_Enable) {
		wait1Msec(25);
	}

	// Score 4th cone
	Auto_Stack(&ConeCount, 1);
	Set_Lift(-10);
	wait1Msec(400);

	// Drop off 4th cone
	Set_Intake(-100);
	wait1Msec(200);
	Set_Intake(0);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Get into position for scoring first mogo
	Drive(125,-2400);					// Always -(1500+(ConeCount-1)*350))
	while(Drive_Enable) {
		wait1Msec(25);
	} // 	while(Drive_Enable) {

	Turn(120,-45);
	while(Turn_Enable) {
		wait1Msec(25);
	} // 	while(Turn_Enable) {

	Drive(120,-825);
	while(Drive_Enable) {
		wait1Msec(25);
	} // while(Drive_Enable) {

	Turn(120,-90);
	while(Turn_Enable) {
		wait1Msec(25);
	} // while(Turn_Enable) {

	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Drop off first mogo
	Drive(125,650);
	while(Drive_Enable) {
		wait1Msec(25);
	} // while(Mogo_Enable || Drive_Enable) {

	stopTask(Auto_Mogo);
	Set_Mogo(100);
	Drive(120,250);
	while(Drive_Enable) {
		wait1Msec(25);
	}
	Set_Mogo(50);

	wait1Msec(250);
	Robot_MOI -= Mobile_Goal_Mass*.15*.15; 	// We've dropped off mogo's
	Robot_Mass -= Mobile_Goal_Mass;

	Set_Mogo(-50);

	Drive(125,-700);
	//use this command again so in case the bars try to push the mogo intake up again, it will stay down
	while(Drive_Enable) {
		wait1Msec(25);
	} // while(Drive_Enable) {
	startTask(Auto_Mogo);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Get in position for second mogo
	Mogo(-100);
	while(Mogo_Enable) {
		wait1Msec(25);
	} // while(Mogo_Enable) {

	Turn(120,90);
	while(Turn_Enable) {
		wait1Msec(25);
	} // while(Turn_Enable) {

	Drive(120,-970);
	while(Drive_Enable) {
		wait1Msec(25);
	} // while(Drive_Enable) {

	Turn(120,135);
	while(Turn_Enable) {
		wait1Msec(25);
	} // while(Turn_Enable) {

	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Get second mogo

	Mogo(100);
	Drive(120,1500);
	while(Drive_Enable || Mogo_Enable) {
		wait1Msec(25);
	} // while(Drive_Enable) {

	Mogo(-100);
	while(Mogo_Enable) {
		wait1Msec(25);
	} // while(Mogo_Enable) {

	Robot_MOI += Mobile_Goal_Mass*.15*.15; 	// We've picked up a mogo
	Robot_Mass += Mobile_Goal_Mass;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Get another cone

	// Reset counter
	ConeCount = 0;

	// Get into position
	Drive(110,350);
	Set_Lift(80);
	while(Drive_Enable) {
		wait1Msec(25);
	}
	Set_Lift(20);

	// Drop down lift
	/*
	clearTimer(T1);
	timer = time1(T1);
	while(SensorValue[Lift_Down_Switch] == 0 && timer < 1000) {
		timer = time1(T1);
		Set_Lift(100);
	}
	*/

	// Drop chainbar
	Auto_Stack(&ConeCount, -1);
	wait1Msec(200);

	// Grab cone
	Auto_Stack(&ConeCount, 1);
	wait1Msec(200);

	// Drop off cone
	Set_Intake(-100);
	wait1Msec(200);
	Set_Intake(0);

	/////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Score second Mogo
	Drive(125,-2225);
	while(Drive_Enable) {
		wait1Msec(25);
	}

	// Lift up a bit (to prevent mogo from catching)
	Set_Lift(-100);
	wait1Msec(200);
	Set_Lift(-10);

	// Turn into position (align with 10 pt bar)
	Turn(120,135);
	while(Turn_Enable) {
		wait1Msec(25);
	}

	// Drive forward to drop off 2nd mogo
	Drive(120,250);
	clearTimer(T1);
	Mogo(100);
	while(Drive_Enable || Mogo_Enable) {
		if(time1(T1) > 1000) { Drive(0,0); Mogo(0); Drive_Enable = 0; Mogo_Enable = 0; }
		wait1Msec(25);
	}

	// Back up/release 2nd mogo
	Drive(120,-1200);
	while(Drive_Enable) {
		wait1Msec(25);
	}

	// Flip mogo
	SensorValue[Mogo_Tip] = 1;
	wait1Msec(500);
	Drive(120,700);
	Mogo(-100);
	while(Drive_Enable || Mogo_Enable) {
		wait1Msec(25);
	}

	// End of auto
	wait1Msec(20000);

} // task autonomous

task usercontrol() {
	// Start tasks
	startTask(Joystick_Velocity_Control);		// Restricts acceleration of drive motors
	startTask(Tank_Drive);									// Controls tank drive
	startTask(Tele_Mogo);										// Controls mogo intake
	startTask(Tele_Lift);										// Controls lift
	startTask(Tele_Auto_Stacker);
	startTask(Tele_Intake);
	startTask(Tele_Chain_Bar);
	startTask(Tele_Mogo_Tipper);
	startTask(LCD);													// Updates LCD
	// Infinite loop to keep tele-op running
	while(true) {
		Drive_Enable = 0;
		Drive_Assist_Enable = 0;
		Turn_Enable  = 0;
		wait1Msec(50);
	}
} // task main()
